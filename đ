use std::sync::Mutex;
use macroquad::math::Vec2;

#[derive(Clone, Copy)]
pub struct AABB {
    pub x: f32,
    pub y: f32,
    pub w: f32,
    pub h: f32,
}

impl AABB {
    pub fn new(x: f32, y: f32, w: f32, h: f32) -> AABB {
        AABB { x, y, w, h }
    }

    pub fn from_vec(pos: Vec2, size: Vec2) -> AABB {
        AABB { x: pos.x, y: pos.y, w: size.x, h: size.y }
    }
}

struct FreeList<T> {
    pub elements: Vec<Option<T>>,
    pub free: Vec<usize>,
}

impl<T> FreeList<T> {
    pub fn new() -> Self {
        Self {
            elements: Vec::new(),
            free: Vec::new(),
        }
    }

    pub fn vstavi(&mut self, el: T) -> usize {
        if self.free.len() > 0 {
            let i = self.free.pop().unwrap();
            self.elements[i] = Some(el);
            return i;
        }
        else {
            self.elements.push(Some(el));
            return self.elements.len() - 1;
        }
    }

    pub fn izbrisi(&mut self, index: usize) {
        self.elements[index] = None;
        self.free.push(index);
    }
}

pub struct DinamicenAABBRef(usize);
pub struct StaticenAABBRef(usize);

pub struct Physics {
    dinamicni: FreeList<AABB>,
    staticni: FreeList<AABB>,
}

static GLOBAL_PHYSICS: Mutex<Option<Physics>> = Mutex::new(None);

pub mod physics {
    use crate::collision::*;

    pub fn init() {
        let mut opt = GLOBAL_PHYSICS.lock().unwrap();
        *opt = Some(Physics {
            dinamicni: FreeList::new(),
            staticni: FreeList::new(),
        });
    }

    pub fn dodaj_dinamicen_obj(aabb: AABB) -> DinamicenAABBRef {
        let mut physics_mutex_guard = GLOBAL_PHYSICS.lock().unwrap();
        let physics = physics_mutex_guard.as_mut().unwrap();

        let i = physics.dinamicni.vstavi(aabb);
        DinamicenAABBRef(i)
    }

    pub fn dodaj_staticen_obj(aabb: AABB) -> StaticenAABBRef {
        let mut physics_mutex_guard = GLOBAL_PHYSICS.lock().unwrap();
        let physics = physics_mutex_guard.as_mut().unwrap();

        let i = physics.staticni.vstavi(aabb);
        StaticenAABBRef(i)
    }

    pub fn izbrisi_dinamicen_obj(aabb_ref: &DinamicenAABBRef) {
        let mut physics_mutex_guard = GLOBAL_PHYSICS.lock().unwrap();
        let physics = physics_mutex_guard.as_mut().unwrap();

        physics.dinamicni.izbrisi(aabb_ref.0);
    }

    pub fn izbrisi_staticen_obj(aabb_ref: &StaticenAABBRef) {
        let mut physics_mutex_guard = GLOBAL_PHYSICS.lock().unwrap();
        let physics = physics_mutex_guard.as_mut().unwrap();

        physics.staticni.izbrisi(aabb_ref.0);
    }

    pub fn premakni_obj(aabb_ref: &DinamicenAABBRef, premik: Vec2) {
        let mut physics_mutex_guard = GLOBAL_PHYSICS.lock().unwrap();
        let physics = physics_mutex_guard.as_mut().unwrap();

        let aabb = physics.dinamicni.elements[aabb_ref.0].as_mut().unwrap();
        aabb.x += premik.x;
        aabb.y += premik.y;
    }

    pub fn pozicija_obj(aabb_ref: &DinamicenAABBRef) -> Vec2 {
        let mut physics_mutex_guard = GLOBAL_PHYSICS.lock().unwrap();
        let physics = physics_mutex_guard.as_mut().unwrap();

        let aabb = physics.dinamicni.elements[aabb_ref.0].unwrap();
        Vec2::new(aabb.x, aabb.y)
    }

    pub fn resi_trke() {
        let mut physics_mutex_guard = GLOBAL_PHYSICS.lock().unwrap();
        let physics = physics_mutex_guard.as_mut().unwrap();
    }

    pub fn narisi_aabbje() {
        let mut physics_mutex_guard = GLOBAL_PHYSICS.lock().unwrap();
        let physics = physics_mutex_guard.as_mut().unwrap();


    }
}

impl Drop for StaticenAABBRef {
    fn drop(&mut self) {
        physics::izbrisi_staticen_obj(self);
    }
}

impl Drop for DinamicenAABBRef {
    fn drop(&mut self) {
        physics::izbrisi_dinamicen_obj(self);
    }
}

